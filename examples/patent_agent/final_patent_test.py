"""
ä¸“åˆ©æ’°å†™æ™ºèƒ½ä½“æœ€ç»ˆæµ‹è¯•

ä½¿ç”¨ä¼˜åŒ–çš„æç¤ºè¯ç›´æ¥è°ƒç”¨å·¥å…·å‡½æ•°
"""

import asyncio
import os
from dotenv import load_dotenv
from datetime import datetime

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv('/Users/zhangyanlong/workspaces/openai-agents-python/.env')

from main_agent import patent_agent
from agents import Runner


async def test_with_tool_call():
    """æµ‹è¯•é€šè¿‡Agentè°ƒç”¨å·¥å…·å‡½æ•°"""
    print("\n" + "=" * 70)
    print("ğŸ”§ æµ‹è¯•ï¼šé€šè¿‡Agentè°ƒç”¨write_patent_applicationå·¥å…·")
    print("=" * 70)

    prompt = """
    è¯·ä½¿ç”¨ write_patent_application å·¥å…·æ’°å†™ä¸“åˆ©ç”³è¯·æ–‡ä»¶ï¼Œæä¾›ä»¥ä¸‹æ‰€æœ‰å‚æ•°ï¼š

    invention_description: åŸºäºæ·±åº¦å­¦ä¹ çš„æ™ºèƒ½æ¨èç³»ç»Ÿï¼Œé€šè¿‡å·ç§¯ç¥ç»ç½‘ç»œåˆ†æç”¨æˆ·è¡Œä¸ºæ•°æ®ï¼ŒåŒ…æ‹¬æµè§ˆè®°å½•ã€ç‚¹å‡»è¡Œä¸ºã€è´­ä¹°å†å²ç­‰ï¼Œæ„å»ºç”¨æˆ·ç”»åƒå¹¶å®ç°ä¸ªæ€§åŒ–å•†å“æ¨èã€‚ç³»ç»Ÿé‡‡ç”¨å¤šå±‚ç¥ç»ç½‘ç»œæ¶æ„ï¼ŒåŒ…æ‹¬åµŒå…¥å±‚ã€éšè—å±‚å’Œè¾“å‡ºå±‚ï¼Œèƒ½å¤Ÿæ•æ‰ç”¨æˆ·å’Œç‰©å“ä¹‹é—´çš„å¤æ‚éçº¿æ€§å…³ç³»ã€‚

    technical_field: äººå·¥æ™ºèƒ½ã€æœºå™¨å­¦ä¹ ã€æ•°æ®æŒ–æ˜ã€æ·±åº¦å­¦ä¹ 

    patent_type: invention

    background_info: ç°æœ‰æ¨èç³»ç»Ÿä¸»è¦åŸºäºååŒè¿‡æ»¤å’Œå†…å®¹è¿‡æ»¤ï¼Œå­˜åœ¨å†·å¯åŠ¨é—®é¢˜ã€æ¨èå‡†ç¡®ç‡æœ‰é™ã€æ— æ³•æ•æ‰ç”¨æˆ·å…´è¶£åŠ¨æ€å˜åŒ–ç­‰é—®é¢˜ã€‚ä¼ ç»Ÿæ–¹æ³•éš¾ä»¥å¤„ç†å¤§è§„æ¨¡ç”¨æˆ·å’Œç‰©å“æ•°æ®ã€‚

    specific_problems: 1. æé«˜æ¨èå‡†ç¡®ç‡ï¼›2. è§£å†³å†·å¯åŠ¨é—®é¢˜ï¼›3. æ•æ‰ç”¨æˆ·å…´è¶£åŠ¨æ€å˜åŒ–ï¼›4. å¤„ç†å¤§è§„æ¨¡æ•°æ®çš„é«˜æ•ˆæ€§

    solution: é‡‡ç”¨å¤šå±‚ç¥ç»ç½‘ç»œæ¶æ„ï¼Œç»“åˆåµŒå…¥å±‚ã€éšè—å±‚å’Œè¾“å‡ºå±‚ã€‚èåˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨èæŠ€æœ¯ï¼Œå®ç°å®æ—¶å­¦ä¹ ç”¨æˆ·åé¦ˆï¼Œä¸æ–­ä¼˜åŒ–æ¨èæ•ˆæœã€‚ç³»ç»ŸåŒ…æ‹¬æ•°æ®é‡‡é›†æ¨¡å—ã€ç‰¹å¾æå–æ¨¡å—ã€æ¨¡å‹è®­ç»ƒæ¨¡å—å’Œæ¨èç”Ÿæˆæ¨¡å—ã€‚

    beneficial_effects: æ¨èå‡†ç¡®ç‡æå‡30%ä»¥ä¸Šï¼Œæœ‰æ•ˆè§£å†³å†·å¯åŠ¨é—®é¢˜ï¼Œæå‡ç”¨æˆ·æ»¡æ„åº¦å’Œè½¬åŒ–ç‡ï¼Œè®¡ç®—æ•ˆç‡æå‡50%ï¼Œç³»ç»Ÿå¯æ‰©å±•æ€§å¼ºã€‚

    applicant_name: æ™ºèƒ½ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸

    applicant_address: åŒ—äº¬å¸‚æµ·æ·€åŒºä¸­å…³æ‘ç§‘æŠ€å›­åŒºåˆ›æ–°å¤§å¦Aåº§15å±‚

    inventor_name: å¼ å·¥ç¨‹å¸ˆ

    è¯·ç¡®ä¿è°ƒç”¨å·¥å…·å¹¶è¿”å›å®Œæ•´ç»“æœã€‚
    """

    result = await Runner.run(patent_agent, prompt)
    return result.final_output


async def test_enhanced_prompt():
    """æµ‹è¯•å¢å¼ºæç¤ºè¯"""
    print("\n" + "=" * 70)
    print("âœ¨ æµ‹è¯•ï¼šå¢å¼ºæç¤ºè¯ï¼ˆæ— å·¥å…·è°ƒç”¨ï¼‰")
    print("=" * 70)

    prompt = """
    è¯·ç›´æ¥æ’°å†™ä¸€ä»½å®Œæ•´çš„å‘æ˜ä¸“åˆ©ç”³è¯·æ–‡ä»¶ï¼ŒæŒ‰ç…§ä»¥ä¸‹ç»“æ„ï¼š

    ## å‘æ˜åç§°
    åŸºäºæ·±åº¦å­¦ä¹ çš„æ™ºèƒ½æ¨èç³»ç»Ÿ

    ## æŠ€æœ¯é¢†åŸŸ
    æœ¬å‘æ˜æ¶‰åŠäººå·¥æ™ºèƒ½æŠ€æœ¯é¢†åŸŸï¼Œå…·ä½“æ˜¯ä¸€ç§åŸºäºæ·±åº¦å­¦ä¹ çš„æ™ºèƒ½æ¨èç³»ç»Ÿã€‚

    ## èƒŒæ™¯æŠ€æœ¯
    ç°æœ‰æŠ€æœ¯ä¸­ï¼Œæ¨èç³»ç»Ÿä¸»è¦åŸºäºååŒè¿‡æ»¤å’Œå†…å®¹è¿‡æ»¤æ–¹æ³•ã€‚ååŒè¿‡æ»¤é€šè¿‡åˆ†æç”¨æˆ·è¡Œä¸ºç›¸ä¼¼æ€§è¿›è¡Œæ¨èï¼Œä½†å­˜åœ¨å†·å¯åŠ¨é—®é¢˜ï¼›å†…å®¹è¿‡æ»¤ä¾èµ–ç‰©å“ç‰¹å¾åŒ¹é…ï¼Œéš¾ä»¥æ•æ‰ç”¨æˆ·å…´è¶£çš„å¤æ‚å˜åŒ–ã€‚ä¼ ç»Ÿæ–¹æ³•å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š
    1. æ¨èå‡†ç¡®ç‡ä¸é«˜
    2. æ— æ³•å¤„ç†å†·å¯åŠ¨åœºæ™¯
    3. éš¾ä»¥æ•æ‰ç”¨æˆ·å…´è¶£çš„åŠ¨æ€å˜åŒ–
    4. è®¡ç®—æ•ˆç‡ä½ï¼Œéš¾ä»¥å¤„ç†å¤§è§„æ¨¡æ•°æ®

    ## å‘æ˜å†…å®¹
    ### è¦è§£å†³çš„æŠ€æœ¯é—®é¢˜
    æœ¬å‘æ˜è¦è§£å†³çš„æŠ€æœ¯é—®é¢˜æ˜¯ï¼šå¦‚ä½•æé«˜æ¨èç³»ç»Ÿçš„å‡†ç¡®ç‡ã€è§£å†³å†·å¯åŠ¨é—®é¢˜ã€æ•æ‰ç”¨æˆ·å…´è¶£åŠ¨æ€å˜åŒ–ï¼Œå¹¶å®ç°é«˜æ•ˆçš„å¤§è§„æ¨¡æ•°æ®å¤„ç†ã€‚

    ### æŠ€æœ¯è§£å†³æ–¹æ¡ˆ
    æœ¬å‘æ˜æä¾›ä¸€ç§åŸºäºæ·±åº¦å­¦ä¹ çš„æ™ºèƒ½æ¨èç³»ç»Ÿï¼ŒåŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š
    (1) æ•°æ®é‡‡é›†æ­¥éª¤ï¼šé‡‡é›†ç”¨æˆ·è¡Œä¸ºæ•°æ®ï¼ŒåŒ…æ‹¬æµè§ˆè®°å½•ã€ç‚¹å‡»è¡Œä¸ºã€è´­ä¹°å†å²ç­‰ï¼›
    (2) ç‰¹å¾æå–æ­¥éª¤ï¼šä½¿ç”¨æ·±åº¦ç¥ç»ç½‘ç»œæå–ç”¨æˆ·å’Œç‰©å“çš„ç‰¹å¾è¡¨ç¤ºï¼›
    (3) æ¨¡å‹è®­ç»ƒæ­¥éª¤ï¼šè®­ç»ƒå¤šå±‚ç¥ç»ç½‘ç»œï¼ŒåŒ…æ‹¬åµŒå…¥å±‚ã€éšè—å±‚å’Œè¾“å‡ºå±‚ï¼›
    (4) æ¨èç”Ÿæˆæ­¥éª¤ï¼šåŸºäºè®­ç»ƒå¥½çš„æ¨¡å‹ç”Ÿæˆä¸ªæ€§åŒ–æ¨èç»“æœã€‚

    ### æœ‰ç›Šæ•ˆæœ
    ä¸ç°æœ‰æŠ€æœ¯ç›¸æ¯”ï¼Œæœ¬å‘æ˜å…·æœ‰ä»¥ä¸‹æœ‰ç›Šæ•ˆæœï¼š
    1. æ¨èå‡†ç¡®ç‡æå‡30%ä»¥ä¸Šï¼›
    2. æœ‰æ•ˆè§£å†³å†·å¯åŠ¨é—®é¢˜ï¼›
    3. æå‡ç”¨æˆ·æ»¡æ„åº¦å’Œè½¬åŒ–ç‡ï¼›
    4. è®¡ç®—æ•ˆç‡æå‡50%ï¼›
    5. ç³»ç»Ÿå¯æ‰©å±•æ€§å¼ºã€‚

    ## é™„å›¾è¯´æ˜
    å›¾1æ˜¯æœ¬å‘æ˜ç³»ç»Ÿçš„æ•´ä½“æ¶æ„å›¾ï¼›
    å›¾2æ˜¯æ·±åº¦ç¥ç»ç½‘ç»œç»“æ„ç¤ºæ„å›¾ï¼›
    å›¾3æ˜¯æ¨èæµç¨‹å›¾ã€‚

    ## å…·ä½“å®æ–½æ–¹å¼
    ä¸‹é¢ç»“åˆé™„å›¾è¯¦ç»†è¯´æ˜æœ¬å‘æ˜çš„å…·ä½“å®æ–½æ–¹å¼...

    ## æƒåˆ©è¦æ±‚ä¹¦
    1. ä¸€ç§åŸºäºæ·±åº¦å­¦ä¹ çš„æ™ºèƒ½æ¨èç³»ç»Ÿï¼Œå…¶ç‰¹å¾åœ¨äºï¼ŒåŒ…æ‹¬ï¼š
    æ•°æ®é‡‡é›†æ¨¡å—ï¼Œç”¨äºé‡‡é›†ç”¨æˆ·è¡Œä¸ºæ•°æ®ï¼›
    ç‰¹å¾æå–æ¨¡å—ï¼Œç”¨äºæå–ç”¨æˆ·å’Œç‰©å“çš„ç‰¹å¾è¡¨ç¤ºï¼›
    æ¨¡å‹è®­ç»ƒæ¨¡å—ï¼Œç”¨äºè®­ç»ƒå¤šå±‚ç¥ç»ç½‘ç»œï¼›
    æ¨èç”Ÿæˆæ¨¡å—ï¼Œç”¨äºç”Ÿæˆä¸ªæ€§åŒ–æ¨èç»“æœã€‚

    2. æ ¹æ®æƒåˆ©è¦æ±‚1æ‰€è¿°çš„ç³»ç»Ÿï¼Œå…¶ç‰¹å¾åœ¨äºï¼Œæ‰€è¿°å¤šå±‚ç¥ç»ç½‘ç»œåŒ…æ‹¬åµŒå…¥å±‚ã€éšè—å±‚å’Œè¾“å‡ºå±‚ã€‚

    3. æ ¹æ®æƒåˆ©è¦æ±‚1æ‰€è¿°çš„ç³»ç»Ÿï¼Œå…¶ç‰¹å¾åœ¨äºï¼Œè¿˜åŒ…æ‹¬å®æ—¶å­¦ä¹ æ¨¡å—ï¼Œç”¨äºæ ¹æ®ç”¨æˆ·åé¦ˆåŠ¨æ€è°ƒæ•´æ¨¡å‹å‚æ•°ã€‚

    4. æ ¹æ®æƒåˆ©è¦æ±‚1æ‰€è¿°çš„ç³»ç»Ÿï¼Œå…¶ç‰¹å¾åœ¨äºï¼Œæ‰€è¿°ç”¨æˆ·è¡Œä¸ºæ•°æ®åŒ…æ‹¬æµè§ˆè®°å½•ã€ç‚¹å‡»è¡Œä¸ºå’Œè´­ä¹°å†å²ã€‚

    5. æ ¹æ®æƒåˆ©è¦æ±‚1æ‰€è¿°çš„ç³»ç»Ÿï¼Œå…¶ç‰¹å¾åœ¨äºï¼Œè¿˜åŒ…æ‹¬å†·å¯åŠ¨å¤„ç†æ¨¡å—ï¼Œç”¨äºå¤„ç†æ–°ç”¨æˆ·å’Œæ–°ç‰©å“çš„æ¨èé—®é¢˜ã€‚

    ç”³è¯·äººï¼šæ™ºèƒ½ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸
    å‘æ˜äººï¼šå¼ å·¥ç¨‹å¸ˆ
    """

    result = await Runner.run(patent_agent, prompt)
    return result.final_output


async def test_step_by_step():
    """æµ‹è¯•åˆ†æ­¥æ’°å†™"""
    print("\n" + "=" * 70)
    print("ğŸ“‹ æµ‹è¯•ï¼šåˆ†æ­¥æ’°å†™ä¸“åˆ©")
    print("=" * 70)

    prompt = """
    æˆ‘éœ€è¦ä½ åˆ†æ­¥éª¤å¸®æˆ‘æ’°å†™ä¸€ä»½ä¸“åˆ©ç”³è¯·æ–‡ä»¶ã€‚

    ç¬¬ä¸€æ­¥ï¼šè¯·å…ˆå†™å‡ºå‘æ˜åç§°ã€æŠ€æœ¯é¢†åŸŸå’ŒèƒŒæ™¯æŠ€æœ¯éƒ¨åˆ†ã€‚

    å‘æ˜ä¿¡æ¯ï¼š
    - åç§°ï¼šæ™ºèƒ½åˆ¶é€ ä¸­çš„è´¨é‡æ£€æµ‹ç³»ç»Ÿ
    - æŠ€æœ¯é¢†åŸŸï¼šæ™ºèƒ½åˆ¶é€ ã€è®¡ç®—æœºè§†è§‰
    - ç”³è¯·äººï¼šå·¥ä¸šç§‘æŠ€æœ‰é™å…¬å¸
    - å‘æ˜äººï¼šæå·¥ç¨‹å¸ˆ

    è¯·å¼€å§‹ç¬¬ä¸€æ­¥çš„æ’°å†™ã€‚
    """

    result = await Runner.run(patent_agent, prompt)
    return result.final_output


async def analyze_and_save(test_name, content, test_num):
    """åˆ†æå¹¶ä¿å­˜ç»“æœ"""
    print(f"\nğŸ“Š æµ‹è¯• {test_num} åˆ†æ:")
    print("-" * 70)

    lines = content.split('\n')
    chars = len(content)
    words = len(content.split())

    print(f"   æ€»è¡Œæ•°: {len(lines)}")
    print(f"   æ€»å­—ç¬¦æ•°: {chars}")
    print(f"   æ€»è¯æ•°: {words}")

    # æ£€æŸ¥å…³é”®å†…å®¹
    content_checks = {
        "å‘æ˜åç§°": any("å‘æ˜åç§°" in line or "åç§°" in line for line in lines),
        "æŠ€æœ¯é¢†åŸŸ": "æŠ€æœ¯é¢†åŸŸ" in content,
        "èƒŒæ™¯æŠ€æœ¯": "èƒŒæ™¯æŠ€æœ¯" in content,
        "å‘æ˜å†…å®¹": "å‘æ˜å†…å®¹" in content or "è¦è§£å†³çš„æŠ€æœ¯é—®é¢˜" in content,
        "æœ‰ç›Šæ•ˆæœ": "æœ‰ç›Šæ•ˆæœ" in content or "æœ‰ç›Šæ•ˆæœ" in content,
        "æƒåˆ©è¦æ±‚": "æƒåˆ©è¦æ±‚" in content,
        "é™„å›¾è¯´æ˜": "é™„å›¾è¯´æ˜" in content,
    }

    print(f"\n   åŒ…å«å†…å®¹:")
    for item, exists in content_checks.items():
        status = "âœ“" if exists else "âœ—"
        print(f"     {status} {item}")

    # è´¨é‡è¯„åˆ†
    score = sum(content_checks.values()) / len(content_checks) * 100
    print(f"\n   è´¨é‡è¯„åˆ†: {score:.1f}%")

    # ä¿å­˜å•ä¸ªæµ‹è¯•ç»“æœ
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"test_result_{test_num}_{timestamp}.txt"

    with open(filename, "w", encoding="utf-8") as f:
        f.write(f"æµ‹è¯• {test_num}: {test_name}\n")
        f.write("=" * 70 + "\n\n")
        f.write(f"æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"å­—ç¬¦æ•°: {chars}\n")
        f.write(f"è¡Œæ•°: {len(lines)}\n")
        f.write(f"è¯„åˆ†: {score:.1f}%\n\n")
        f.write("å®Œæ•´å†…å®¹:\n")
        f.write("-" * 70 + "\n")
        f.write(content)

    print(f"   ğŸ’¾ å·²ä¿å­˜åˆ°: {filename}")

    return {
        "name": test_name,
        "chars": chars,
        "lines": len(lines),
        "score": score,
        "checks": content_checks
    }


async def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("\n" + "=" * 70)
    print("ğŸ¯ ä¸“åˆ©æ’°å†™æ™ºèƒ½ä½“æœ€ç»ˆæµ‹è¯•")
    print("=" * 70)

    # æ£€æŸ¥ API
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        print("âŒ æœªé…ç½® API å¯†é’¥")
        return

    print(f"âœ“ API å¯†é’¥: {api_key[:10]}...")

    # è¿è¡Œæµ‹è¯•
    tests = [
        ("å·¥å…·å‡½æ•°è°ƒç”¨", test_with_tool_call),
        ("å¢å¼ºæç¤ºè¯", test_enhanced_prompt),
        ("åˆ†æ­¥æ’°å†™", test_step_by_step),
    ]

    results = []
    test_num = 0

    for test_name, test_func in tests:
        test_num += 1
        try:
            print(f"\nâ³ æ­£åœ¨è¿è¡Œ: {test_name}...")
            content = await test_func()
            result = await analyze_and_save(test_name, content, test_num)
            results.append(result)

            # æ˜¾ç¤ºå‰200å­—ç¬¦ä½œä¸ºé¢„è§ˆ
            print(f"\n   ğŸ“„ å†…å®¹é¢„è§ˆ:")
            print("   " + "-" * 66)
            preview = content[:200].replace('\n', '\n   ')
            print(f"   {preview}...")
            print("   " + "-" * 66)

        except Exception as e:
            print(f"âŒ {test_name} å¤±è´¥: {e}")
            results.append({
                "name": test_name,
                "error": str(e)
            })

    # ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š
    print("\n" + "=" * 70)
    print("ğŸ“ˆ æœ€ç»ˆæµ‹è¯•æŠ¥å‘Š")
    print("=" * 70)

    successful_tests = [r for r in results if "error" not in r]
    print(f"\nâœ… æˆåŠŸæµ‹è¯•: {len(successful_tests)}/{len(results)}")

    if successful_tests:
        avg_score = sum(r["score"] for r in successful_tests) / len(successful_tests)
        print(f"ğŸ“Š å¹³å‡è¯„åˆ†: {avg_score:.1f}%")

        print(f"\nğŸ† æœ€ä½³æµ‹è¯•:")
        best = max(successful_tests, key=lambda x: x["score"])
        print(f"   {best['name']}: {best['score']:.1f}%")

    # è¯¦ç»†ç»“æœè¡¨
    print(f"\nğŸ“‹ è¯¦ç»†ç»“æœ:")
    print("-" * 70)
    print(f"{'æµ‹è¯•åç§°':<20} {'è¯„åˆ†':<10} {'å­—ç¬¦æ•°':<10} {'è¡Œæ•°':<8}")
    print("-" * 70)
    for r in successful_tests:
        print(f"{r['name']:<20} {r['score']:<10.1f} {r['chars']:<10} {r['lines']:<8}")

    print("\n" + "=" * 70)
    if avg_score >= 80:
        print("ğŸ‰ ä¼˜ç§€ï¼ä¸“åˆ©æ’°å†™æ™ºèƒ½ä½“è¡¨ç°è‰¯å¥½ï¼")
    elif avg_score >= 60:
        print("ğŸ‘ è‰¯å¥½ï¼ä¸“åˆ©æ’°å†™æ™ºèƒ½ä½“åŸºæœ¬å¯ç”¨")
    else:
        print("âš ï¸ éœ€è¦æ”¹è¿›ï¼ä¸“åˆ©æ’°å†™æ™ºèƒ½ä½“éœ€è¦ä¼˜åŒ–")

    print("=" * 70)


if __name__ == "__main__":
    asyncio.run(main())
